[{"id":"85cd6f6ae0dbb8213fef87b009cc23bd","title":"css-grid","content":"css之grid\n\n\n\n\n\n\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/grid\nhttps://article.itxueyuan.com/GjlqAZ\n浏览器兼容性\n\n\n\n\n\n\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/grid#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7\n\n使用display: grid | inline-grid \ngrid\n该元素的行为类似块级元素并且根据网格模型布局它的内容。\n\n\ninline-grid\n元素的行为类似于内联元素并且它的内容根据网格盒模型布局。\n它等同于 inline grid。\n\n\n\n相关属性grid\n\n\n\n\n\n\n\n\ngrid 是一个 CSS 简写属性，可以用来设置以下属性：\n显式网格属性： grid-template-rows、grid-template-columns 和 grid-template-areas。\n隐式网格属性： grid-auto-rows、grid-auto-columns 和 grid-auto-flow。\n间距属性： grid-column-gap 和 grid-row-gap。\ngrid-template-rows\n\n\n\n\n\n\n\n\ngrid-template-rows 该属性是基于 网格行 的维度，去定义网格线的名称和网格轨道的尺寸大小。\ngrid-template-columnsgrid-template-areasgrid-auto-rowsgrid-auto-columnsgrid-auto-flowgrid-column-gapgrid-row-gap","slug":"css-grid","date":"2023-02-08T14:29:01.000Z","categories_index":"前端","tags_index":"css","author_index":"YeZhou"},{"id":"392205eb06b7b17a2bf05b4fd3e5501c","title":"关于部署记录","content":"关于部署的那些事\n\n\n\n\n\n\n\n\n最近记性不太好，先记录留待之后慢慢补充吧~\n\n一、docker安装及相关操作\n安装docker\n\nyum install docker\n\n查看版本\n\ndocker version\n\n[root@VM_0_10_centos ~]# docker --version\nDocker version 1.13.1, build 07f3374/1.13.1\n[root@VM_0_10_centos ~]# docker version\nClient:\nVersion:         1.13.1\nAPI version:     1.26\nPackage version:\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n\n\n\n\n\n\n\n\n\n\n在运行docker的过程中可能会弹出这个报错~Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?可以通过这个指令解决service docker start\n\ndocker运行容器指令\n\ndocker run -it 镜像名 /bin/bash\n\n\ndocker退出容器\n\nexit\n\n\ndocker查看容器\n\ndocker ps -a\n\n\ndocker查看运行的容器\n\n\ndocker ps\n\n\ndocker重启容器\n\ndocker restart 容器ID\n\n\ndocker进入容器\n\ndocker exec -it 容器ID /bin/bash\n\n二、MongoDB安装及相关操作\n查找docker中的mongo\n\ndocker search mongo\n\n\n直接拉取最新版本\n\ndocker pull mongo:latest\n\n\n查看是否已经安装docker\n\ndocker images\n\n\n运行容器\n\ndocker run -itd --name mongo -p 27017:27017 mongo --auth\n\n\n\n\n\n\n\n\n\n\n-p 27017:27017 ：映射容器服务的 27017 端口到宿主机的 27017 端口–auth：需要密码才能访问容器服务\n\n到这里就安装成功啦~可以通过docker ps查看容器的运行信息\n\n添加用户名和密码，并连接\n\n\n$ docker exec -it mongo mongo admin\n# 创建一个名为 admin，密码为 123456 的用户。\n>  db.createUser(&#123; user:'admin',pwd:'123456',roles:[ &#123; role:'userAdminAnyDatabase', db: 'admin'&#125;,\"readWriteAnyDatabase\"]&#125;);\n# 尝试使用上面创建的用户信息进行连接。\n> db.auth('admin', '123456')\n\n三、node安装及相关操作\nnode查看版本\n\ndocker search node\n\n\n获取最新的node镜像版本\n\ndocker pull node:latest\n\n\n查看当前本地images镜像\n\ndocker images\n\n\n运行容器\n\ndocker run -itd --name node node\n\n\n进入容器查看node版本\n\ndocker exec -it node /bin/bash\n\n\n全局安装pm2\n\nnpm install -g pm2\n\n四、关于文件上传的那些事\n安装依赖\n\nyum -y install lrzsz \n\n\n上传文件\n\nrz\n\n\n下载文件\n\nsz\n\n\n由于rz只能上传文件不能上传文件夹，所以需要打包之后上传，上传之后需要解压操作\n\nunzip 压缩文件名 -d 压缩后的文件名\n// example\nunzip name-a.zip -d name-b\n\n五、Koa项目部署\n在项目根目录创建Dockerfile\n\nFROM node:alpine\nADD . /app/\nWORKDIR /app\nRUN yarn install\nEXPOSE 3000\nCMD [\"yarn\", \"start\"]\n\n\n将项目上传至服务器中\n\n构建镜像\n\n\ndocker build -t 镜像名 .\n\n\n\n\n\n\n\n\n\n\n千万不要忘记最后有个点 .\n\n运行镜像\n\n#启动镜像 -d表示后台执行，-p 9000:3000表示指定本地的9000端口隐射到容器内的3000端口，docker_demo为镜像名称\ndocker run -d -p 9000:3000 docker_demo\n\n六、部署前端项目\n安装nginx\n\ndocker pull nginx\n\n\n查看镜像\n\ndocker images\n\n\n在项目根目录中增加default.conf有关nginx配置\n\nserver &#123;\n    listen       80;\n    server_name  主机IP; # 修改为docker服务宿主机的ip\n\n    location / &#123;\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html =404;\n    &#125;\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html &#123;\n        root   html;\n    &#125;\n&#125;\n\n\n同上，在根目录创建Dockerfile文件\n\nFROM nginx\n\nRUN rm /etc/nginx/conf.d/default.conf\n\nADD default.conf /etc/nginx/conf.d/\n\nCOPY dist/ /usr/share/nginx/html/\n\n\n上传至服务器之后构建docker镜像\n\ndocker build -t blog-web .\n\n\n启动docker容器\n\ndocker run -d -p 80:80 --name blog-web blog-web\n\n\n那么，就可以愉快的玩耍了~\n\n","slug":"关于部署记录","date":"2023-02-07T01:45:05.000Z","categories_index":"部署","tags_index":"docker,部署","author_index":"YeZhou"},{"id":"ba316baf5ce1889e9486578e0545bd88","title":"毕业旅行那些事","content":"\n\n\n\n\n\n\n\n\n\n[20220422成都]总要有一场旅行，从成都走到西藏，趁着年轻，把最好的时光花在丈量距离\n\n\n\n\n\n\n\n\n\n\n[20220422磨西古镇]我还可以躺在山顶触摸星星，与月亮窃窃私语，像好久不见的老朋友一样\n\n\n\n\n\n\n\n\n\n\n[20220423海螺沟]保持热爱 奔赴山海 第一站从海螺沟开始\n未完待续…\n","slug":"毕业旅行的那些事","date":"2022-09-17T17:36:02.000Z","categories_index":"生活","tags_index":"旅行","author_index":"YeZhou"},{"id":"f1cabef6cdf8492d0abc18fe53dc4f41","title":"关于webpack的一些优化","content":"关于webpack的优化\n\n\n\n\n\n\n\n\n在webpack打包的过程中，总是觉得等的时间好漫长，so，康康有没有啥方法可以提升一下打包的速度\nwebpack 5.68.0 compiled with 2 warnings in 29784 ms\nDone in 31.27s\n\nProgressPlugin\n\n\n\n\n\n\n\n\n咱想知道一下打包进度是啥，等着好无聊\nconst &#123; ProgressPlugin &#125; = require(\"webpack\");\n\n  plugins: [\n    ...\n    new ProgressPlugin(&#123;\n      activeModules: true,\n      entries: true,\n      modules: true,\n      modulesCount: 5000,\n      profile: false,\n      dependencies: false,\n      dependenciesCount: 10000,\n    &#125;),\n  ],\n\ncache-loader\n\n\n\n\n\n\n\n\n\n在一些性能开销较大的 loader 之前添加此 loader，以将结果缓存到磁盘里\n请注意，保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。\n\nyarn add cache-loader -D\n\n&#123;\n  test: /\\.(tsx|ts)$/,\n  use: [\n    \"cache-loader\",\n    &#123;\n      loader: \"babel-loader\",\n      options: &#123;\n        presets: [\"@babel/preset-react\"],\n        cacheDirectory: true,\n      &#125;,\n    &#125;,\n    \"ts-loader\",\n  ],\n  exclude: path.resolve(__dirname, \"node_modules\"),\n&#125;,\n\n重新yarn build一下，发现速度快了6s~\nwebpack 5.68.0 compiled with 2 warnings in 23323 ms\nDone in 25.20s\n\nwebpack-parallel-uglify-pluginyarn add webpack-parallel-uglify-plugin -D\n\n在webpack中增加以下配置\nconst ParallelUglifyPlugin = require(\"webpack-parallel-uglify-plugin\");\n\n  plugins: [\n    new ParallelUglifyPlugin(&#123;\n      cacheDir: \".cache/\",\n      uglifyJS: &#123;\n        output: &#123;\n          beautify: false,\n          comments: false,\n        &#125;,\n        warnings: false,\n      &#125;,\n      test: /.(js|ts|tsx)$/g,\n      sourceMap: false,\n    &#125;),\n  ],\n\n真好，又优化了2s左右的时间\nwebpack 5.68.0 compiled with 2 warnings in 21980 ms\nDone in 23.34s.\n\nsplitChunks\n\n\n\n\n\n\n\n\n我们可以使用 SplitChunks 的分块策略\noptimization: &#123;\n  //...\n  splitChunks: &#123;\n    // async异步导入\n    // initoal同步导入\n    // all 异步/同步\n    chunks: 'all',\n    minSize: 20000,  // 最小尺寸，拆分出来的一个包的大小最小为minSize 默认 20kb\n    maxSize: 20000,  // 将大于maxSize的包，拆成不小于minSize的包 默认 0， 一般会设置和minSize一样\n    minChunks: 2,    // 引入的包，至少被导入几次 默认 1次\n    cacheGroups: &#123;   // 缓存分组\n      vendor: &#123;  // 第三方打包到vendor\n        test: /[\\/]node_modules[\\/]/,  // 匹配node_modules\n        filename: 'js/[id]_vendors.js',  // 与name属性区别是 filename可用占位符, name固定名称\n        // name: 'js/check_vendors.js',  \n        priority: -10  // 当所有打包条件都满足时，按priority优先级来打包，大的先打包\n      &#125;,\n      default: &#123;  // 默认打包，当其他条件不满足\n        minChunks: 2,\n        filename: 'js/[id]_common.js',  // 一般是多入口会打包common.js\n        priority: -20\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n重新打包一次，哇哦，又快了~\nwebpack 5.68.0 compiled with 2 warnings in 19554 ms\nDone in 21.19s.\n\nterser-webpack-pluginconst TerserPlugin = require('terser-webpack-plugin')\n//...\noptimization: &#123;\n  minimize: true,  // minimizer配置开关\n  minimizer: [\n    new TerserPlugin(&#123;   // 默认不需要去配置, 压缩js\n      parallel: true,   // 使用cpu多核来构建\n      extractComments: false,  // 打包后的 LICENSE.txt 注释文件去吃\n      terserOptions: &#123;\n        compress: &#123;\n          arguments: true,\n          dead_code: true,\n        &#125;, // 设置压缩相关的选项；\n        mangle: true, // 设置丑化相关的选项，可以直接设置为true；\n        toplevel: true, // 底层变量是否进行转换；\n        keep_classnames: false, // 保留类的名称；\n        keep_fnames: false, // 保留函数的名称；\n      &#125;\n    &#125;),\n  ],\n&#125;\n\n18.69s，啊，真香\nwebpack 5.68.0 compiled with 2 warnings in 17272 ms\nDone in 18.69s.\n","slug":"关于webpack的一些优化","date":"2022-09-17T07:31:38.000Z","categories_index":"前端","tags_index":"webpack,优化","author_index":"YeZhou"},{"id":"d35aa425aa50b4a7aa1d4ffaa6cb155b","title":"无头浏览器大佬借鉴指南","content":"无头浏览器\n\n\n\n\n\n\n\n\n参考链接\nhttps://www.zhihu.com/question/314668782/answer/615201155\nhttps://juejin.cn/post/6844903504276881422\nhttps://blog.51cto.com/u_15127557/3781423\nhttps://www.infoq.cn/article/ZZDG2iqhZ73elE8vIsye\nhttps://blog.csdn.net/weixin_45426836/article/details/111462607\nhttps://www.jianshu.com/p/92cfecd94ada\nhttps://www.jianshu.com/p/7f5a7bd79f59/\n是个啥“无头”这个词来源于最初的“无头计算机(Headless computer)”。维基百科关于的“无头计算机”词条：\n\n\n\n\n\n\n\n\n\n无头系统（headless system）是指已配置为无须显示器（即“头”）、键盘和鼠标操作的计算机系统或设备。无头系统通常通过网络连接控制，但也有部分无头系统的设备需要通过 RS-232 串行连接进行设备的管理。服务器通常采用无头模式以降低运作成本。\n\n简单来说就是通过编程来控制它自动执行测试、截屏等任务\n\n有啥好处\n软件生产中的自动化\n无头浏览器比真正的浏览器更快\n节省开发人员的时间\n使用无头浏览器脚本监视性能\n\n无头浏览器种类\nPhantomJS：Scriptable Headless WebKit 【Star - 25877】\nslimerjs：A scriptable browser like PhantomJS, based on Firefox 【Star - 2738】\nsplash：Lightweight, scriptable browser as a service with an HTTP API 【1974】\ntriflejs：Headless automation for Internet Explorer 【Star - 764】\n\n无头浏览器初探 puppeteer[demo1.js]\n关于 puppeteer\n\n\n\n\n\n\n\n\n\n\nhttps://www.youdao.com/result?word=puppeteer&amp;lang=en\n\n\n\n\n\n\n\n\n\nPuppeteer 的执行原理就是像操纵木偶的人一样，通过各种方式(接口)进行操纵浏览器帮你执行各种操作的工具\n\n\n\n\n\n\n\n\n\n\n\nPuppeteer 使用 DevTools 协议 与浏览器进行通信。\nBrowser 实例可以拥有浏览器上下文。\nBrowserContext 实例定义了一个浏览会话并可拥有多个页面。\nPage 至少有一个框架：主框架。 可能还有其他框架由 iframe 或 框架标签 创建。\nframe 至少有一个执行上下文 - 默认的执行上下文 - 框架的 JavaScript 被执行。 一个框架可能有额外的与 扩展 关联的执行上下文。\nWorker 具有单一执行上下文，并且便于与 WebWorkers 进行交互。\n\n\n安装无头浏览器\n\npnpm add puppeteer\n\n\n\n\n\n\n\n\n\n\n此处贴一下 puppeteer 的文档：http://www.puppeteerjs.com/\n\n实现简易 DEMO\n\nconst puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.baidu.com\");\n  leafConsole(INFO_SUCCESS, \"open http://www.baidu.com success\");\n  await page.close();\n  leafConsole(INFO_SUCCESS, \"close http://www.baidu.com success\");\n&#125;\n\nheadlessTest();\n\n通过以上代码，可以运行http://www.baidu.com，并在之后关闭浏览器。\n如何判断无头浏览器[demo2.js]\n通过 User Agent 判断\n\nif (/HeadlessChrome/.test(window.navigator.userAgent)) &#123;\n  console.log(\"Chrome headless detected\");\n&#125;\n\n\n通过 plugins 判断\n\nif (navigator.plugins.length == 0) &#123;\n  console.log(\"It may be Chrome headless\");\n&#125;\n\n\nnavigate.languages\n\n\n\n\n\n\n\n\n\n\nnavigator.language 和 navigator.languages。头一个是指浏览器界面的语言，后一个返回的是个数组，里面存储的是浏览器用户的所有次选语言。然而，在无头模式里，navigator.languages 返回的是个空字符串\nif (navigator.languages == \"\") &#123;\n  console.log(\"Chrome headless detected\");\n&#125;\n\n\n\n\n\n\n\n\n\n\n当然还有其它方法，就先列举了一些\n无头浏览器的能干啥\n生成网页的截图或者 PDF 文件\n模拟键盘的操作、对 UI 进行测试、对表单进行提交\n用浏览器自带的分析工具对页面进行分析\n等等\n\n无头浏览器的使用生成网页的截图或者 PDF 文件[demo2.js]const puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.baidu.com\", &#123;\n    waitUntil: \"load\",\n  &#125;);\n  try &#123;\n    await page.screenshot(&#123; path: `../assets/$&#123;new Date().getTime()&#125;.png` &#125;);\n    leafConsole(INFO_SUCCESS, \"screenshot png success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"screenshot png failure\");\n  &#125;\n  try &#123;\n    await page.pdf(&#123; path: `../assets/$&#123;new Date().getTime()&#125;.pdf` &#125;);\n    leafConsole(INFO_SUCCESS, \"screenshot pdf success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"screenshot pdf failure\");\n  &#125;\n  await page.close();\n&#125;\n\nheadlessTest();\n\n模拟操作[demo3.js]const puppeteer = require(\"puppeteer\");\nconst request = require(\"request\");\nconst &#123; createWriteStream &#125; = require(\"fs\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n  const page = await browser.newPage();\n\n  try &#123;\n    await page.goto(\"http://image.baidu.com\", &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await page.waitForSelector(\"html\");\n    leafConsole(INFO_SUCCESS, \"open image.baidu.com success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"open image.baidu.com failure\");\n    return;\n  &#125;\n\n  try &#123;\n    await page.type(\"#kw\", \"小姐姐\");\n    await page.click(\"#homeSearchForm > .s_btn_wr\");\n    await page.waitForSelector(\".imgitem > a\");\n    leafConsole(INFO_SUCCESS, \"search key success\");\n  &#125; catch (err) &#123;\n    leafConsole(INFO_FAILURE, \"search key failure\");\n    return;\n  &#125;\n\n  const urls = await page.$$eval(\".imgitem > a\", (img) =>\n    img.map((imgItem) => imgItem.href)\n  );\n  for (let i = 0; i &lt; urls.length; i++) &#123;\n    await page.goto(urls[i], &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await downLoadImg(page, i);\n  &#125;\n&#125;\n\nasync function downLoadImg(page, index) &#123;\n  await page.waitForSelector(\".currentImg\");\n  const imgSrc = await page.evaluate(() => &#123;\n    let img = document.querySelector(\".currentImg\");\n    return img.src;\n  &#125;);\n  try &#123;\n    const fileName = `$&#123;new Date().getTime()&#125;-$&#123;index&#125;-小姐姐.png`;\n    await download(imgSrc, `../assets/$&#123;fileName&#125;`);\n    leafConsole(INFO_SUCCESS, `download success filename:$&#123;fileName&#125;`);\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"download failure\");\n  &#125;\n&#125;\n\nfunction download(path, name) &#123;\n  return new Promise((resolve, reject) => &#123;\n    let ws = new createWriteStream(name);\n    ws.on(\"finish\", function () &#123;\n      ws.end();\n      resolve();\n    &#125;);\n    ws.on(\"error\", reject);\n    request(&#123;\n      url: path,\n      headers: &#123;\n        Referer: \"no-referrer-when-downgrade\",\n        \"User-Agent\":\n          \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\",\n      &#125;,\n    &#125;).pipe(ws);\n  &#125;);\n&#125;\n\nheadlessTest();\n\n测试页面性能[demo4.js]const puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole &#125; = require(\"./constants\");\n\nconst targetUrl = \"http://image.baidu.com\";\nconst times = 5;\nconst record = [];\n\nasync function headlessTest() &#123;\n  for (let i = 0; i &lt; times; i++) &#123;\n    const browser = await puppeteer.launch(&#123; headless: true &#125;);\n    const page = await browser.newPage();\n    await page.goto(targetUrl, &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n\n    const timing = JSON.parse(\n      await page.evaluate(() => JSON.stringify(window.performance.timing))\n    );\n    const res = calculate(timing);\n    record.push(res);\n    await browser.close();\n    leafConsole(INFO_SUCCESS, `End of the test[$&#123;i + 1&#125;/$&#123;times&#125;]`);\n    leafConsole(INFO_SUCCESS, `whiteScreenTime:$&#123;res.whiteScreenTime&#125;ms`);\n    leafConsole(INFO_SUCCESS, `requestTime:$&#123;res.requestTime&#125;ms`);\n  &#125;\n\n  let whiteScreenTime = 0;\n  let requestTime = 0;\n\n  for (let item of record) &#123;\n    whiteScreenTime += item.whiteScreenTime;\n    requestTime += item.requestTime;\n  &#125;\n\n  leafConsole(INFO_SUCCESS, `---------result---------`);\n  leafConsole(INFO_SUCCESS, `targetUrl:$&#123;targetUrl&#125;`);\n  leafConsole(\n    INFO_SUCCESS,\n    `The average blank screen time is:$&#123;whiteScreenTime / times&#125; ms`\n  );\n  leafConsole(\n    INFO_SUCCESS,\n    `The average page request time is:$&#123;requestTime / times&#125; ms`\n  );\n&#125;\n\nfunction calculate(timing) &#123;\n  const result = &#123;&#125;;\n  // 白屏时间\n  result.whiteScreenTime = timing.responseStart - timing.navigationStart;\n  // 请求时间\n  result.requestTime = timing.responseEnd - timing.responseStart;\n  return result;\n&#125;\n\nheadlessTest();\n\n爬虫[demo5.js]const puppeteer = require(\"puppeteer\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n  const page = await browser.newPage();\n\n  try &#123;\n    await page.goto(\"http://image.baidu.com\", &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await page.waitForSelector(\"html\");\n    leafConsole(INFO_SUCCESS, \"open image.baidu.com success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"open image.baidu.com failure\");\n    return;\n  &#125;\n\n  try &#123;\n    await page.type(\"#kw\", \"小姐姐\");\n    await page.click(\"#homeSearchForm > .s_btn_wr\");\n    await page.waitForSelector(\".imgitem > a\");\n    leafConsole(INFO_SUCCESS, \"search key success\");\n  &#125; catch (err) &#123;\n    leafConsole(INFO_FAILURE, \"search key failure\");\n    return;\n  &#125;\n\n  const urls = await page.$$eval(\".imgitem > a\", (img) =>\n    img.map((imgItem) => (&#123;\n      src: imgItem.href,\n      title: imgItem.title,\n      name: imgItem.name,\n    &#125;))\n  );\n\n  let list = JSON.stringify(urls);\n  let file = path.join(\"../assets/\", `test-$&#123;new Date().getTime()&#125;.json`);\n  fs.writeFile(file, list, (err) => &#123;\n    if (err) &#123;\n      leafConsole(INFO_FAILURE, \"export json error\");\n      return;\n    &#125;\n    leafConsole(INFO_SUCCESS, \"export json success\");\n  &#125;);\n&#125;\n\nheadlessTest();\n\n监听请求和响应[demo6.js]const puppeteer = require(\"puppeteer\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.yeyezhou.com\");\n\n  page.on(\"request\", (request) => &#123;\n    if (request.url() === \"http://www.yeyezhou.com/api/a/article/list\") &#123;\n      console.log(request.resourceType());\n      console.log(request.method());\n      console.log(request.headers());\n    &#125;\n  &#125;);\n\n  page.on(\"response\", (response) => &#123;\n    if (response.url() === \"http://www.yeyezhou.com/api/a/article/list\") &#123;\n      console.log(response.status());\n      console.log(response.headers());\n    &#125;\n  &#125;);\n&#125;\n\nheadlessTest();\n\n无头浏览器优化\n\n\n\n\n\n\n\n\nhttps://www.jianshu.com/p/7f5a7bd79f59/\nhttps://juejin.cn/post/6844903984101064717\n优化 Chromium 启动项\n\n\n\n\n\n\n\n\nChromium 启动参数表：https://peter.sh/experiments/chromium-command-line-switches/\n网上大佬的优化配置参数\nconst browser = await puppeteer.launch(&#123;\n  headless: true,\n  args: [\n    \"–disable-gpu\",\n    \"–disable-dev-shm-usage\",\n    \"–disable-setuid-sandbox\",\n    \"–no-first-run\",\n    \"–no-sandbox\",\n    \"–no-zygote\",\n    \"–single-process\",\n  ],\n&#125;);\n\n优化 Chromium 执行流程\n\n\n\n\n\n\n\n\n优化的其中一种手段就是减少 Chromium 启动的次数，做到复用 Chromium 每次只打开一个 tab 页然后关闭。可以使用 puppeteer 提供的 puppeteer.connect()方法连接到当前打开的浏览器\n通过这种方法，可以把流程 A 成功优化成流程 B\nA\n请求到达-&gt;启动 Chromium-&gt;打开 tab 页-&gt;运行代码-&gt;关闭 tab 页-&gt;关闭 Chromium-&gt;返回数据\nB\n请求到达-&gt;连接 Chromium-&gt;打开 tab 页-&gt;运行代码-&gt;关闭 tab 页-&gt;返回数据\n\n\n\n\n\n\n\n\n\n使用puppeteer.connect比puppeteer.launch启动一个浏览器实例要快很多,所以当我们需要开启多个broswer实例时，可以通过缓存wsEndpoint来达到复用的目的\nlet wsEndpoint = await cache.get(Parser.WS_KEY);\nlet broswer;\ntry &#123;\n    browser = !wsEndpoint\n        ? await puppeteer.launch(config)\n        : await puppeteer.connect(&#123;\n              browserWSEndpoint: this.wsEndpoint,\n          &#125;);\n&#125; catch (err) &#123;\n    browser = await puppeteer.launch(config);\n&#125; finally &#123;\n    wsEndpoint = this.browser.wsEndpoint();\n    await cache.set(Parser.WS_KEY, 60 * 60 * 1000, this.wsEndpoint);\n&#125;\n\n利用 cluster 优化 Puppeteer\n\n\n\n\n\n\n\n\n通常情况下我们会使用 ​.map()​ 搭配 ​Promise.all()​ 的方式并行处理异步，但是在使用 ​Puppeteer​ 批量截图时发现 ​Promise.all​ 会打开多个浏览器，导致机器性能急剧下降。\n\n\n\n\n\n\n\n\n\nCluster 原理解析：https://zhuanlan.zhihu.com/p/157987519\n避免使用 page.waitFor 让程序自己决定啥时候继续会更好拦截一些没有必要加载的资源\n\n\n\n\n\n\n\n\n当我们使用 puppeteer 对页面异步渲染的 dom 结构进行解析时，往往需要等待页面完成渲染完成之后，才能使用脚本进行操作。但页面渲染过程中也包含了许多静态资源如：图片&#x2F;音频&#x2F;视频&#x2F;样式文件等。此时我们可以通过 page.setRequestInterception 方法，对网页请求进行过滤，拦截静态资源的请求，加快页面渲染速度。代码示例如下：\n// 开启请求拦截功能\npage.setRequestInterception(true);\n\npage.on('request', async req => &#123;\n    // 根据请求类型过滤\n    const resourceType = req.resourceType();\n    if (resourceType === 'image') &#123;\n        req.abort();\n    else &#123;\n        req.continue();\n    &#125;\n&#125;);\n\nconst blockedResourceTypes &#x3D; [\n    &#39;image&#39;,\n    &#39;media&#39;,\n    &#39;font&#39;,\n    &#39;texttrack&#39;,\n    &#39;object&#39;,\n    &#39;beacon&#39;,\n    &#39;csp_report&#39;,\n    &#39;imageset&#39;,\n];\n\nconst skippedResources &#x3D; [\n    &#39;quantserve&#39;,\n    &#39;adzerk&#39;,\n    &#39;doubleclick&#39;,\n    &#39;adition&#39;,\n    &#39;exelator&#39;,\n    &#39;sharethrough&#39;,\n    &#39;cdn.api.twitter&#39;,\n    &#39;google-analytics&#39;,\n    &#39;googletagmanager&#39;,\n    &#39;google&#39;,\n    &#39;fontawesome&#39;,\n    &#39;facebook&#39;,\n    &#39;analytics&#39;,\n    &#39;optimizely&#39;,\n    &#39;clicktale&#39;,\n    &#39;mixpanel&#39;,\n    &#39;zedo&#39;,\n    &#39;clicksor&#39;,\n    &#39;tiqcdn&#39;,\n];","slug":"无头浏览器初探","date":"2022-09-17T07:31:38.000Z","categories_index":"前端","tags_index":"无头浏览器,puppeteer","author_index":"YeZhou"}]