[{"id":"f1cabef6cdf8492d0abc18fe53dc4f41","title":"关于webpack的一些优化","content":"关于webpack的优化\n\n\n\n\n\n\n\n\n在webpack打包的过程中，总是觉得等的时间好漫长，so，康康有没有啥方法可以提升一下打包的速度\nwebpack 5.68.0 compiled with 2 warnings in 29784 ms\nDone in 31.27s\n\nProgressPlugin\n\n\n\n\n\n\n\n\n咱想知道一下打包进度是啥，等着好无聊\nconst &#123; ProgressPlugin &#125; = require(\"webpack\");\n\n  plugins: [\n    ...\n    new ProgressPlugin(&#123;\n      activeModules: true,\n      entries: true,\n      modules: true,\n      modulesCount: 5000,\n      profile: false,\n      dependencies: false,\n      dependenciesCount: 10000,\n    &#125;),\n  ],\n\ncache-loader\n\n\n\n\n\n\n\n\n\n在一些性能开销较大的 loader 之前添加此 loader，以将结果缓存到磁盘里\n请注意，保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。\n\nyarn add cache-loader -D\n\n&#123;\n  test: /\\.(tsx|ts)$/,\n  use: [\n    \"cache-loader\",\n    &#123;\n      loader: \"babel-loader\",\n      options: &#123;\n        presets: [\"@babel/preset-react\"],\n        cacheDirectory: true,\n      &#125;,\n    &#125;,\n    \"ts-loader\",\n  ],\n  exclude: path.resolve(__dirname, \"node_modules\"),\n&#125;,\n\n重新yarn build一下，发现速度快了6s~\nwebpack 5.68.0 compiled with 2 warnings in 23323 ms\nDone in 25.20s\n\nwebpack-parallel-uglify-pluginyarn add webpack-parallel-uglify-plugin -D\n\n在webpack中增加以下配置\nconst ParallelUglifyPlugin = require(\"webpack-parallel-uglify-plugin\");\n\n  plugins: [\n    new ParallelUglifyPlugin(&#123;\n      cacheDir: \".cache/\",\n      uglifyJS: &#123;\n        output: &#123;\n          beautify: false,\n          comments: false,\n        &#125;,\n        warnings: false,\n      &#125;,\n      test: /.(js|ts|tsx)$/g,\n      sourceMap: false,\n    &#125;),\n  ],\n\n真好，又优化了2s左右的时间\nwebpack 5.68.0 compiled with 2 warnings in 21980 ms\nDone in 23.34s.\n\nsplitChunks\n\n\n\n\n\n\n\n\n我们可以使用 SplitChunks 的分块策略\noptimization: &#123;\n  //...\n  splitChunks: &#123;\n    // async异步导入\n    // initoal同步导入\n    // all 异步/同步\n    chunks: 'all',\n    minSize: 20000,  // 最小尺寸，拆分出来的一个包的大小最小为minSize 默认 20kb\n    maxSize: 20000,  // 将大于maxSize的包，拆成不小于minSize的包 默认 0， 一般会设置和minSize一样\n    minChunks: 2,    // 引入的包，至少被导入几次 默认 1次\n    cacheGroups: &#123;   // 缓存分组\n      vendor: &#123;  // 第三方打包到vendor\n        test: /[\\/]node_modules[\\/]/,  // 匹配node_modules\n        filename: 'js/[id]_vendors.js',  // 与name属性区别是 filename可用占位符, name固定名称\n        // name: 'js/check_vendors.js',  \n        priority: -10  // 当所有打包条件都满足时，按priority优先级来打包，大的先打包\n      &#125;,\n      default: &#123;  // 默认打包，当其他条件不满足\n        minChunks: 2,\n        filename: 'js/[id]_common.js',  // 一般是多入口会打包common.js\n        priority: -20\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n重新打包一次，哇哦，又快了~\nwebpack 5.68.0 compiled with 2 warnings in 19554 ms\nDone in 21.19s.\n\nterser-webpack-pluginconst TerserPlugin = require('terser-webpack-plugin')\n//...\noptimization: &#123;\n  minimize: true,  // minimizer配置开关\n  minimizer: [\n    new TerserPlugin(&#123;   // 默认不需要去配置, 压缩js\n      parallel: true,   // 使用cpu多核来构建\n      extractComments: false,  // 打包后的 LICENSE.txt 注释文件去吃\n      terserOptions: &#123;\n        compress: &#123;\n          arguments: true,\n          dead_code: true,\n        &#125;, // 设置压缩相关的选项；\n        mangle: true, // 设置丑化相关的选项，可以直接设置为true；\n        toplevel: true, // 底层变量是否进行转换；\n        keep_classnames: false, // 保留类的名称；\n        keep_fnames: false, // 保留函数的名称；\n      &#125;\n    &#125;),\n  ],\n&#125;\n\n18.69s，啊，真香\nwebpack 5.68.0 compiled with 2 warnings in 17272 ms\nDone in 18.69s.\n","slug":"关于webpack的一些优化","date":"2022-09-17T07:31:38.000Z","categories_index":"前端","tags_index":"webpack,优化","author_index":"YeZhou"},{"id":"d35aa425aa50b4a7aa1d4ffaa6cb155b","title":"无头浏览器大佬借鉴指南","content":"无头浏览器\n\n\n\n\n\n\n\n\n参考链接\nhttps://www.zhihu.com/question/314668782/answer/615201155\nhttps://juejin.cn/post/6844903504276881422\nhttps://blog.51cto.com/u_15127557/3781423\nhttps://www.infoq.cn/article/ZZDG2iqhZ73elE8vIsye\nhttps://blog.csdn.net/weixin_45426836/article/details/111462607\nhttps://www.jianshu.com/p/92cfecd94ada\nhttps://www.jianshu.com/p/7f5a7bd79f59/\n是个啥“无头”这个词来源于最初的“无头计算机(Headless computer)”。维基百科关于的“无头计算机”词条：\n\n\n\n\n\n\n\n\n\n无头系统（headless system）是指已配置为无须显示器（即“头”）、键盘和鼠标操作的计算机系统或设备。无头系统通常通过网络连接控制，但也有部分无头系统的设备需要通过 RS-232 串行连接进行设备的管理。服务器通常采用无头模式以降低运作成本。\n\n简单来说就是通过编程来控制它自动执行测试、截屏等任务\n\n有啥好处\n软件生产中的自动化\n无头浏览器比真正的浏览器更快\n节省开发人员的时间\n使用无头浏览器脚本监视性能\n\n无头浏览器种类\nPhantomJS：Scriptable Headless WebKit 【Star - 25877】\nslimerjs：A scriptable browser like PhantomJS, based on Firefox 【Star - 2738】\nsplash：Lightweight, scriptable browser as a service with an HTTP API 【1974】\ntriflejs：Headless automation for Internet Explorer 【Star - 764】\n\n无头浏览器初探 puppeteer[demo1.js]\n关于 puppeteer\n\n\n\n\n\n\n\n\n\n\nhttps://www.youdao.com/result?word=puppeteer&amp;lang=en\n\n\n\n\n\n\n\n\n\nPuppeteer 的执行原理就是像操纵木偶的人一样，通过各种方式(接口)进行操纵浏览器帮你执行各种操作的工具\n\n\n\n\n\n\n\n\n\n\n\nPuppeteer 使用 DevTools 协议 与浏览器进行通信。\nBrowser 实例可以拥有浏览器上下文。\nBrowserContext 实例定义了一个浏览会话并可拥有多个页面。\nPage 至少有一个框架：主框架。 可能还有其他框架由 iframe 或 框架标签 创建。\nframe 至少有一个执行上下文 - 默认的执行上下文 - 框架的 JavaScript 被执行。 一个框架可能有额外的与 扩展 关联的执行上下文。\nWorker 具有单一执行上下文，并且便于与 WebWorkers 进行交互。\n\n\n安装无头浏览器\n\npnpm add puppeteer\n\n\n\n\n\n\n\n\n\n\n此处贴一下 puppeteer 的文档：http://www.puppeteerjs.com/\n\n实现简易 DEMO\n\nconst puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.baidu.com\");\n  leafConsole(INFO_SUCCESS, \"open http://www.baidu.com success\");\n  await page.close();\n  leafConsole(INFO_SUCCESS, \"close http://www.baidu.com success\");\n&#125;\n\nheadlessTest();\n\n通过以上代码，可以运行http://www.baidu.com，并在之后关闭浏览器。\n如何判断无头浏览器[demo2.js]\n通过 User Agent 判断\n\nif (/HeadlessChrome/.test(window.navigator.userAgent)) &#123;\n  console.log(\"Chrome headless detected\");\n&#125;\n\n\n通过 plugins 判断\n\nif (navigator.plugins.length == 0) &#123;\n  console.log(\"It may be Chrome headless\");\n&#125;\n\n\nnavigate.languages\n\n\n\n\n\n\n\n\n\n\nnavigator.language 和 navigator.languages。头一个是指浏览器界面的语言，后一个返回的是个数组，里面存储的是浏览器用户的所有次选语言。然而，在无头模式里，navigator.languages 返回的是个空字符串\nif (navigator.languages == \"\") &#123;\n  console.log(\"Chrome headless detected\");\n&#125;\n\n\n\n\n\n\n\n\n\n\n当然还有其它方法，就先列举了一些\n无头浏览器的能干啥\n生成网页的截图或者 PDF 文件\n模拟键盘的操作、对 UI 进行测试、对表单进行提交\n用浏览器自带的分析工具对页面进行分析\n等等\n\n无头浏览器的使用生成网页的截图或者 PDF 文件[demo2.js]const puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.baidu.com\", &#123;\n    waitUntil: \"load\",\n  &#125;);\n  try &#123;\n    await page.screenshot(&#123; path: `../assets/$&#123;new Date().getTime()&#125;.png` &#125;);\n    leafConsole(INFO_SUCCESS, \"screenshot png success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"screenshot png failure\");\n  &#125;\n  try &#123;\n    await page.pdf(&#123; path: `../assets/$&#123;new Date().getTime()&#125;.pdf` &#125;);\n    leafConsole(INFO_SUCCESS, \"screenshot pdf success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"screenshot pdf failure\");\n  &#125;\n  await page.close();\n&#125;\n\nheadlessTest();\n\n模拟操作[demo3.js]const puppeteer = require(\"puppeteer\");\nconst request = require(\"request\");\nconst &#123; createWriteStream &#125; = require(\"fs\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n  const page = await browser.newPage();\n\n  try &#123;\n    await page.goto(\"http://image.baidu.com\", &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await page.waitForSelector(\"html\");\n    leafConsole(INFO_SUCCESS, \"open image.baidu.com success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"open image.baidu.com failure\");\n    return;\n  &#125;\n\n  try &#123;\n    await page.type(\"#kw\", \"小姐姐\");\n    await page.click(\"#homeSearchForm > .s_btn_wr\");\n    await page.waitForSelector(\".imgitem > a\");\n    leafConsole(INFO_SUCCESS, \"search key success\");\n  &#125; catch (err) &#123;\n    leafConsole(INFO_FAILURE, \"search key failure\");\n    return;\n  &#125;\n\n  const urls = await page.$$eval(\".imgitem > a\", (img) =>\n    img.map((imgItem) => imgItem.href)\n  );\n  for (let i = 0; i &lt; urls.length; i++) &#123;\n    await page.goto(urls[i], &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await downLoadImg(page, i);\n  &#125;\n&#125;\n\nasync function downLoadImg(page, index) &#123;\n  await page.waitForSelector(\".currentImg\");\n  const imgSrc = await page.evaluate(() => &#123;\n    let img = document.querySelector(\".currentImg\");\n    return img.src;\n  &#125;);\n  try &#123;\n    const fileName = `$&#123;new Date().getTime()&#125;-$&#123;index&#125;-小姐姐.png`;\n    await download(imgSrc, `../assets/$&#123;fileName&#125;`);\n    leafConsole(INFO_SUCCESS, `download success filename:$&#123;fileName&#125;`);\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"download failure\");\n  &#125;\n&#125;\n\nfunction download(path, name) &#123;\n  return new Promise((resolve, reject) => &#123;\n    let ws = new createWriteStream(name);\n    ws.on(\"finish\", function () &#123;\n      ws.end();\n      resolve();\n    &#125;);\n    ws.on(\"error\", reject);\n    request(&#123;\n      url: path,\n      headers: &#123;\n        Referer: \"no-referrer-when-downgrade\",\n        \"User-Agent\":\n          \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\",\n      &#125;,\n    &#125;).pipe(ws);\n  &#125;);\n&#125;\n\nheadlessTest();\n\n测试页面性能[demo4.js]const puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole &#125; = require(\"./constants\");\n\nconst targetUrl = \"http://image.baidu.com\";\nconst times = 5;\nconst record = [];\n\nasync function headlessTest() &#123;\n  for (let i = 0; i &lt; times; i++) &#123;\n    const browser = await puppeteer.launch(&#123; headless: true &#125;);\n    const page = await browser.newPage();\n    await page.goto(targetUrl, &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n\n    const timing = JSON.parse(\n      await page.evaluate(() => JSON.stringify(window.performance.timing))\n    );\n    const res = calculate(timing);\n    record.push(res);\n    await browser.close();\n    leafConsole(INFO_SUCCESS, `End of the test[$&#123;i + 1&#125;/$&#123;times&#125;]`);\n    leafConsole(INFO_SUCCESS, `whiteScreenTime:$&#123;res.whiteScreenTime&#125;ms`);\n    leafConsole(INFO_SUCCESS, `requestTime:$&#123;res.requestTime&#125;ms`);\n  &#125;\n\n  let whiteScreenTime = 0;\n  let requestTime = 0;\n\n  for (let item of record) &#123;\n    whiteScreenTime += item.whiteScreenTime;\n    requestTime += item.requestTime;\n  &#125;\n\n  leafConsole(INFO_SUCCESS, `---------result---------`);\n  leafConsole(INFO_SUCCESS, `targetUrl:$&#123;targetUrl&#125;`);\n  leafConsole(\n    INFO_SUCCESS,\n    `The average blank screen time is:$&#123;whiteScreenTime / times&#125; ms`\n  );\n  leafConsole(\n    INFO_SUCCESS,\n    `The average page request time is:$&#123;requestTime / times&#125; ms`\n  );\n&#125;\n\nfunction calculate(timing) &#123;\n  const result = &#123;&#125;;\n  // 白屏时间\n  result.whiteScreenTime = timing.responseStart - timing.navigationStart;\n  // 请求时间\n  result.requestTime = timing.responseEnd - timing.responseStart;\n  return result;\n&#125;\n\nheadlessTest();\n\n爬虫[demo5.js]const puppeteer = require(\"puppeteer\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n  const page = await browser.newPage();\n\n  try &#123;\n    await page.goto(\"http://image.baidu.com\", &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await page.waitForSelector(\"html\");\n    leafConsole(INFO_SUCCESS, \"open image.baidu.com success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"open image.baidu.com failure\");\n    return;\n  &#125;\n\n  try &#123;\n    await page.type(\"#kw\", \"小姐姐\");\n    await page.click(\"#homeSearchForm > .s_btn_wr\");\n    await page.waitForSelector(\".imgitem > a\");\n    leafConsole(INFO_SUCCESS, \"search key success\");\n  &#125; catch (err) &#123;\n    leafConsole(INFO_FAILURE, \"search key failure\");\n    return;\n  &#125;\n\n  const urls = await page.$$eval(\".imgitem > a\", (img) =>\n    img.map((imgItem) => (&#123;\n      src: imgItem.href,\n      title: imgItem.title,\n      name: imgItem.name,\n    &#125;))\n  );\n\n  let list = JSON.stringify(urls);\n  let file = path.join(\"../assets/\", `test-$&#123;new Date().getTime()&#125;.json`);\n  fs.writeFile(file, list, (err) => &#123;\n    if (err) &#123;\n      leafConsole(INFO_FAILURE, \"export json error\");\n      return;\n    &#125;\n    leafConsole(INFO_SUCCESS, \"export json success\");\n  &#125;);\n&#125;\n\nheadlessTest();\n\n监听请求和响应[demo6.js]const puppeteer = require(\"puppeteer\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.yeyezhou.com\");\n\n  page.on(\"request\", (request) => &#123;\n    if (request.url() === \"http://www.yeyezhou.com/api/a/article/list\") &#123;\n      console.log(request.resourceType());\n      console.log(request.method());\n      console.log(request.headers());\n    &#125;\n  &#125;);\n\n  page.on(\"response\", (response) => &#123;\n    if (response.url() === \"http://www.yeyezhou.com/api/a/article/list\") &#123;\n      console.log(response.status());\n      console.log(response.headers());\n    &#125;\n  &#125;);\n&#125;\n\nheadlessTest();\n\n无头浏览器优化\n\n\n\n\n\n\n\n\nhttps://www.jianshu.com/p/7f5a7bd79f59/\nhttps://juejin.cn/post/6844903984101064717\n优化 Chromium 启动项\n\n\n\n\n\n\n\n\nChromium 启动参数表：https://peter.sh/experiments/chromium-command-line-switches/\n网上大佬的优化配置参数\nconst browser = await puppeteer.launch(&#123;\n  headless: true,\n  args: [\n    \"–disable-gpu\",\n    \"–disable-dev-shm-usage\",\n    \"–disable-setuid-sandbox\",\n    \"–no-first-run\",\n    \"–no-sandbox\",\n    \"–no-zygote\",\n    \"–single-process\",\n  ],\n&#125;);\n\n优化 Chromium 执行流程\n\n\n\n\n\n\n\n\n优化的其中一种手段就是减少 Chromium 启动的次数，做到复用 Chromium 每次只打开一个 tab 页然后关闭。可以使用 puppeteer 提供的 puppeteer.connect()方法连接到当前打开的浏览器\n通过这种方法，可以把流程 A 成功优化成流程 B\nA\n请求到达-&gt;启动 Chromium-&gt;打开 tab 页-&gt;运行代码-&gt;关闭 tab 页-&gt;关闭 Chromium-&gt;返回数据\nB\n请求到达-&gt;连接 Chromium-&gt;打开 tab 页-&gt;运行代码-&gt;关闭 tab 页-&gt;返回数据\n\n\n\n\n\n\n\n\n\n使用puppeteer.connect比puppeteer.launch启动一个浏览器实例要快很多,所以当我们需要开启多个broswer实例时，可以通过缓存wsEndpoint来达到复用的目的\nlet wsEndpoint = await cache.get(Parser.WS_KEY);\nlet broswer;\ntry &#123;\n    browser = !wsEndpoint\n        ? await puppeteer.launch(config)\n        : await puppeteer.connect(&#123;\n              browserWSEndpoint: this.wsEndpoint,\n          &#125;);\n&#125; catch (err) &#123;\n    browser = await puppeteer.launch(config);\n&#125; finally &#123;\n    wsEndpoint = this.browser.wsEndpoint();\n    await cache.set(Parser.WS_KEY, 60 * 60 * 1000, this.wsEndpoint);\n&#125;\n\n利用 cluster 优化 Puppeteer\n\n\n\n\n\n\n\n\n通常情况下我们会使用 ​.map()​ 搭配 ​Promise.all()​ 的方式并行处理异步，但是在使用 ​Puppeteer​ 批量截图时发现 ​Promise.all​ 会打开多个浏览器，导致机器性能急剧下降。\n\n\n\n\n\n\n\n\n\nCluster 原理解析：https://zhuanlan.zhihu.com/p/157987519\n避免使用 page.waitFor 让程序自己决定啥时候继续会更好拦截一些没有必要加载的资源\n\n\n\n\n\n\n\n\n当我们使用 puppeteer 对页面异步渲染的 dom 结构进行解析时，往往需要等待页面完成渲染完成之后，才能使用脚本进行操作。但页面渲染过程中也包含了许多静态资源如：图片&#x2F;音频&#x2F;视频&#x2F;样式文件等。此时我们可以通过 page.setRequestInterception 方法，对网页请求进行过滤，拦截静态资源的请求，加快页面渲染速度。代码示例如下：\n// 开启请求拦截功能\npage.setRequestInterception(true);\n\npage.on('request', async req => &#123;\n    // 根据请求类型过滤\n    const resourceType = req.resourceType();\n    if (resourceType === 'image') &#123;\n        req.abort();\n    else &#123;\n        req.continue();\n    &#125;\n&#125;);\n\nconst blockedResourceTypes &#x3D; [\n    &#39;image&#39;,\n    &#39;media&#39;,\n    &#39;font&#39;,\n    &#39;texttrack&#39;,\n    &#39;object&#39;,\n    &#39;beacon&#39;,\n    &#39;csp_report&#39;,\n    &#39;imageset&#39;,\n];\n\nconst skippedResources &#x3D; [\n    &#39;quantserve&#39;,\n    &#39;adzerk&#39;,\n    &#39;doubleclick&#39;,\n    &#39;adition&#39;,\n    &#39;exelator&#39;,\n    &#39;sharethrough&#39;,\n    &#39;cdn.api.twitter&#39;,\n    &#39;google-analytics&#39;,\n    &#39;googletagmanager&#39;,\n    &#39;google&#39;,\n    &#39;fontawesome&#39;,\n    &#39;facebook&#39;,\n    &#39;analytics&#39;,\n    &#39;optimizely&#39;,\n    &#39;clicktale&#39;,\n    &#39;mixpanel&#39;,\n    &#39;zedo&#39;,\n    &#39;clicksor&#39;,\n    &#39;tiqcdn&#39;,\n];","slug":"无头浏览器初探","date":"2022-09-17T07:31:38.000Z","categories_index":"前端","tags_index":"无头浏览器,puppeteer","author_index":"YeZhou"}]