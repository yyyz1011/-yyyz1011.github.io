[{"id":"495bab8dfa3f797561631b8f7f1d8428","title":"前端-package.json的一些事","content":"一、package.json的一些事\n\n\n\n\n\n\n\n\n参考链接  https://blog.csdn.net/qq_34703156/article/details/121401990\n每个仓库都有package.json的文件，而这个文件也记录了包含项目的配置文件、声明的依赖以及运行的指令等等内容，以本项目为例，一个package.json中有如下内容：\n&#123;\n  \"name\": \"hexo-site\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": &#123;\n    \"build\": \"node_modules/.bin/hexo generate\",\n    \"clean\": \"node_modules/.bin/hexo clean\",\n    \"deploy\": \"node_modules/.bin/hexo deploy\",\n    \"server\": \"node_modules/.bin/hexo server\",\n    \"dev\": \"hexo clean &amp; hexo g &amp; hexo server\",\n    \"upload\": \"npx hexo clean &amp; npx hexo g &amp; npx hexo d\"\n  &#125;,\n  \"hexo\": &#123;\n    \"version\": \"6.3.0\"\n  &#125;,\n  \"dependencies\": &#123;\n    \"hexo\": \"^6.3.0\",\n    \"hexo-deployer-git\": \"^3.0.0\",\n    \"hexo-filter-image\": \"^1.2.3\",\n    \"hexo-generator-archive\": \"^1.0.0\",\n    \"hexo-generator-category\": \"^1.0.0\",\n    \"hexo-generator-index\": \"^2.0.0\",\n    \"hexo-generator-tag\": \"^1.0.0\",\n    \"hexo-renderer-ejs\": \"^2.0.0\",\n    \"hexo-renderer-marked\": \"^5.0.0\",\n    \"hexo-renderer-stylus\": \"^2.1.0\",\n    \"hexo-server\": \"^3.0.0\",\n    \"hexo-theme-aurora\": \"^1.5.5\",\n    \"hexo-theme-landscape\": \"^0.0.3\"\n  &#125;\n&#125;\n\n二、文件中常见字段name\n\n\n\n\n\n\n\n\n项目名称\nversion\n\n\n\n\n\n\n\n\n项目包的版本号，在每次项目改动后，要重新发布的时候都需要手动更新版本号\n版本号的使用规范：\n\n版本号的命名遵循语义化版本 2.0.0 规范，格式为：「主版本号. 次版本号. 修订号」，通常情况下，修改主版本号是做了大的功能性的改动，修改次版本号是新增了新功能，修改修订号就是修复了一些 bug；\n\n如果某个版本的改动较大，并且不稳定，可能如法满足预期的兼容性需求，就需要发布先行版本，先行版本通过会加在版本号的后面，通过 “-” 号连接以点分隔的标识符和版本编译信息：内部版本（alpha）、公测版本（beta）和候选版本（rc，即 release candiate）。\n\n\n三、依赖配置\n\n\n\n\n\n\n\n\n通常项目的依赖包有五中属性\n\ndependencies\n\ndevDependencies\n\npeerDependencies\n\nbundledDependencies\n\noptionalDependencies\n\n\n3.1 dependencies\n\n\n\n\n\n\n\n\ndependencies表示项目在生产环境中必须依赖的包\npnpm install &lt;PACKAGE_NAME>\npnpm install &lt;PACKAGE_NAME> --save\n\n会对应生成一个对象，内容如下\n\"dependencies\": &#123;\n  \"hexo\": \"^6.3.0\",\n&#125;\n\n其中对象中的内容符合key-value，key表示模块的名称，value表示模块的版本，版本号同样遵循[主版本号.次版本号.修订号]\n其中版本号会有三种情况，分别表示为固定版本、波浪号、插入号\n假如是latest则表示安装最新的版本\n\n\n\n\n\n\n\n\n\nNOTE: 不能把测试或者过度的依赖包全部放在dependencies中，避免生产环境出现问题\n固定版本\n\n\n\n\n\n\n\n\n表示安装这个package_name依赖的时候只会安装1.0.0版本\n\"package_name\":\"1.0.0\"\n\n波浪号\n\n\n\n\n\n\n\n\n表示安装这个package_name版本是1.0.x的最新版本（不能低于1.0.2）\n\"package_name\":\"~1.0.2\"\n\n插入号\n\n\n\n\n\n\n\n\n表示安装这个package_name版本是1.x.x的最新版本（不能低于1.0.2）\n\"package_name\":\"^1.0.2\"\n\n3.2 devDependencies\n\n\n\n\n\n\n\n\ndevDependencies表示开发阶段需要用到的依赖，例如webpack、eslint等等，用于辅助开发\npnpm install &lt;PACKAGE_NAME> --save-dev\npnpm install &lt;PACKAGE_NAME> -D\n\n会对应生成一个对象，内容如下\n\"devDependencies\": &#123;\n  \"hexo\": \"^6.3.0\",\n&#125;\n\n3.3 peerDependencies\n\n\n\n\n\n\n\n\n有些情况下，我们的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，我们的项目依赖 A 模块和 B 模块的 1.0 版，而 A 模块本身又依赖 B 模块的 2.0 版。大多数情况下，这不是问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。\n最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的 B 的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。\npeerDependencies 字段就是用来供插件指定其所需要的主工具的版本。\n3.4 optionalDependencies\n\n\n\n\n\n\n\n\n如果需要在找不到包或者安装包失败时，npm 仍然能够继续运行，则可以将该包放在 optionalDependencies 对象中，optionalDependencies 对象中的包会覆盖 dependencies 中同名的包，所以只需在一个地方进行设置即可。\n需要注意，由于 optionalDependencies 中的依赖可能并未安装成功，所以一定要做异常处理，否则当获取这个依赖时，如果获取不到就会报错。\n3.5bundledDependencies\n\n\n\n\n\n\n\n\n上面的几个依赖相关的配置项都是一个对象，而 bundledDependencies 配置项是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。\n需要注意，这个字段数组中的值必须是在 dependencies, devDependencies 两个里面声明过的包才行。\n3.6 engines\n\n\n\n\n\n\n\n\n当这个项目对npm或者node版本有要求的时候，可以配置engines，如果不满足配置中的版本，项目无法正常运行\n\"engines\":&#123;\n    \"node\":\">=8.10.0 &lt; 12.13.0\",\n    \"npm\":\">6.9.0\"\n&#125;\n\n四、脚本配置script\n\n\n\n\n\n\n\n\nscripts 是 package.json 中内置的脚本入口，是 key-value 键值对配置，key 为可运行的命令，可以通过 npm run 来执行命令]\n\"scripts\": &#123;\n  \"build\": \"node_modules/.bin/hexo generate\",\n  \"clean\": \"node_modules/.bin/hexo clean\",\n  \"deploy\": \"node_modules/.bin/hexo deploy\",\n  \"server\": \"node_modules/.bin/hexo server\",\n  \"dev\": \"hexo clean &amp; hexo g &amp; hexo server\",\n  \"upload\": \"npx hexo clean &amp; npx hexo g &amp; npx hexo d\"\n&#125;,\n\n五、发布配置private\n\n\n\n\n\n\n\n\nprivate 字段可以防止我们意外地将私有库发布到 npm 服务器。只需要将该字段设置为 true\n\"private\": true\n\nlicense\n\n\n\n\n\n\n\n\nlicense 字段用于指定软件的开源协议，开源协议表述了其他人获得代码后拥有的权利，可以对代码进行何种操作，何种操作又是被禁止的。常见的协议如下：\nMIT ：只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。\nApache ：类似于 MIT ，同时还包含了贡献者向用户提供专利授权相关的条款。\nGPL ：修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。\n\"license\":\"MIT\"\n\n","slug":"前端-package-json的一些事","date":"2023-02-19T04:55:53.000Z","categories_index":"前端","tags_index":"配置","author_index":"YeZhou"},{"id":"5a2ade3c73b7acbe2fc201db23330b68","title":"前端CSS-实现展开收起","content":"css 实现长文本的展开收起\n\n\n\n\n\n\n\n\n效果可见 ➡ https://codesandbox.io/s/xenodochial-haslett-drohnr?file=/src/App.vue\n&lt;template&gt;\n  &lt;div\n    class&#x3D;&quot;text-wrapper&quot;\n    :class&#x3D;&quot;foldClassName&quot;\n    :style&#x3D;&quot;collapseTextStyle&quot;\n    @click&#x3D;&quot;handleFoldText&quot;\n  &gt;\n    &lt;template v-if&#x3D;&quot;isLineConform&quot;&gt;\n      &lt;span v-show&#x3D;&quot;isFold&quot; class&#x3D;&quot;text-button&quot;&gt;\n        展开\n        &lt;i class&#x3D;&quot;down-arrow&quot; &#x2F;&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n    &lt;span ref&#x3D;&#39;contentRef&#39;&gt;\n      &lt;div&gt;&#123;&#123; content &#125;&#125;&lt;&#x2F;div&gt;\n    &lt;&#x2F;span&gt;\n    &lt;template v-if&#x3D;&quot;isLineConform&quot;&gt;\n      &lt;span v-show&#x3D;&quot;!isFold&quot; class&#x3D;&quot;text-button&quot;&gt;\n        收起\n        &lt;i class&#x3D;&quot;up-arrow&quot; &#x2F;&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport &#123; ref, computed, onMounted &#125; from &quot;vue&quot;;\n\nconst content &#x3D; ref(&#39;这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话这是一段很长的话&#39;);\n\nconst width &#x3D; ref(300); &#x2F;&#x2F; 默认宽度\nconst lineHeight &#x3D; ref(20); &#x2F;&#x2F; 默认行高\nconst hiddenLine &#x3D; ref(3); &#x2F;&#x2F; 超出行数隐藏\n\nlet contentRef &#x3D; ref(null);\n\nlet isFold &#x3D; ref(true);\nlet isLineConform &#x3D; ref(false);\n &#x2F;&#x2F; 文本高度，先设置1000，文本传入获取真实高度后替换\nlet textHeight &#x3D; ref(1000);\n\nconst collapseTextStyle &#x3D; computed(()&#x3D;&gt;&#123;\n  const propWidth &#x3D; width.value;\n  let textWidth;\n  if (\n    typeof propWidth &#x3D;&#x3D;&#x3D; &#39;string&#39;\n    &amp;&amp; propWidth.charAt(propWidth.length - 1) &#x3D;&#x3D;&#x3D; &#39;%&#39;\n  ) &#123;\n    textWidth &#x3D; propWidth;\n  &#125; else &#123;\n    textWidth &#x3D; propWidth + &#39;px&#39;;\n  &#125;\n  return &#123;\n    &#x2F;&#x2F; 文本宽度\n    &#39;--text-width&#39;: textWidth,\n    &#x2F;&#x2F; 设置行高\n    &#39;--text-line-height&#39;: lineHeight.value + &#39;px&#39;,\n    &#x2F;&#x2F; 设置第n行开始省略\n    &#39;--text-hidden-line&#39;: hiddenLine.value,\n  &#125;;\n&#125;);\n\nconst foldClassName &#x3D; computed(()&#x3D;&gt; isFold.value ? &#39;text-fold&#39; : &#39;text-unfold&#39;)\n\nonMounted(()&#x3D;&gt;&#123;\ngetTextHeight()\n&#125;)\n\nfunction handleFoldText()&#123;\n  isFold.value &#x3D; !isFold.value\n&#125;\n\n function getTextHeight() &#123;\n  &#x2F;&#x2F; 计算比例\n  const rate &#x3D; window.innerWidth &#x2F; 375;\n  const contentHeight &#x3D; contentRef.value.offsetHeight;\n  isLineConform.value\n    &#x3D; contentHeight &gt; rate * hiddenLine.value * lineHeight.value;\n  textHeight &#x3D; contentHeight;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.text-wrapper &#123;\n  width: var(--text-width);\n  line-height: var(--text-line-height);\n  overflow: hidden;\n  max-height: calc(var(--text-line-height) * var(--text-hidden-line));\n&#125;\n\n.text-button &#123;\n  margin-left: 5px;\n  margin-right: 10px;\n  height: var(--text-line-height);\n  float: right;\n  clear: both;\n  pointer-events: auto;\n\n  font-family: PingFang SC;\n  font-weight: 500;\n  font-size: 13px;\n  line-height: 18px;\n  text-align: right;\n  color: rgba(22, 24, 35, 0.75);\n  cursor: pointer;\n&#125;\n\n.text-fold &#123;\n  pointer-events: none;\n  text-overflow:ellipsis;\n  overflow:hidden;\n  -webkit-box-orient:vertical;\n  -webkit-line-clamp:var(--text-hidden-line);\n&#125;\n\n.text-fold::before &#123;\n  content: &quot;&quot;;\n  float: right;\n  height: calc((var(--text-hidden-line) - 0.9) * var(--text-line-height));\n  width: 0;\n&#125;\n\n.text-unfold &#123;\n  max-height: calc(var(--text-hidden-line) * var(--text-line-height) * 1px);\n  pointer-events: none;\n&#125;\n\n.down-arrow &#123;\n  margin-left: 5px;\n  margin-top: 6.5px;\n  float: right;\n  width: 0;\n  height: 0;\n  border-width: 5px;\n  border-style: solid;\n  border-color: rgba(22, 24, 35, 0.75) transparent transparent transparent;\n&#125;\n\n.up-arrow &#123;\n  margin-left: 5px;\n  float: right;\n  width: 0;\n  height: 0;\n  border-width: 5px;\n   border-style: solid;\n  border-color: transparent transparent rgba(22, 24, 35, 0.75) transparent;\n&#125;\n&lt;&#x2F;style&gt;\n\n\nvue3版本\n\n\n\n\n\n\n\n\n最新代码可见：https://github.com/yyyz1011/leaf_collapse_component\n&lt;template&gt;\n  &lt;div\n    :class&#x3D;&quot;collapseTextareaClassName&quot;\n    :style&#x3D;&quot;collapseTextareaStyle&quot;\n    @click&#x3D;&quot;handleExpandText&quot;\n  &gt;\n    &lt;template v-if&#x3D;&quot;isShowExpandBtn&quot;&gt;\n      &lt;span v-show&#x3D;&quot;!isExpand&quot; class&#x3D;&quot;text-button&quot;&gt;\n        &lt;slot name&#x3D;&quot;down-arrow-content&quot;&gt;\n          展开\n          &lt;i class&#x3D;&quot;down-arrow&quot; &#x2F;&gt;\n        &lt;&#x2F;slot&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n    &lt;div class&#x3D;&quot;content&quot; ref&#x3D;&quot;contentRef&quot;&gt;\n      &#123;&#123; content &#125;&#125;\n    &lt;&#x2F;div&gt;\n    &lt;template v-if&#x3D;&quot;isShowExpandBtn&quot;&gt;\n      &lt;span v-show&#x3D;&quot;isExpand&quot; class&#x3D;&quot;text-button&quot;&gt;\n        &lt;slot name&#x3D;&quot;up-arrow-content&quot;&gt;\n          收起\n          &lt;i class&#x3D;&quot;up-arrow&quot; &#x2F;&gt;\n        &lt;&#x2F;slot&gt;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; ref, Ref, computed, watch, nextTick &#125; from &quot;vue&quot;;\n\nconst &#123;\n  width &#x3D; &quot;100%&quot;,\n  lineHeight &#x3D; 20,\n  defaultCollapseLine &#x3D; 3,\n  content,\n&#125; &#x3D; defineProps&lt;&#123;\n  width?: string | number; &#x2F;&#x2F; 组件宽度\n  lineHeight?: number; &#x2F;&#x2F; 行高\n  defaultCollapseLine?: number; &#x2F;&#x2F; 默认展示行数\n  content: string; &#x2F;&#x2F; 内容\n&#125;&gt;();\n\nconst contentRef: Ref&lt;null | HTMLElement&gt; &#x3D; ref(null);\n\nconst isExpand: Ref&lt;boolean&gt; &#x3D; ref(true); &#x2F;&#x2F; 是否展开\nconst isShowExpandBtn: Ref&lt;boolean&gt; &#x3D; ref(false); &#x2F;&#x2F; 是否展示展开&#x2F;收起按钮\nconst textHeight: Ref&lt;number&gt; &#x3D; ref(1000);\n\nconst collapseTextareaClassName &#x3D; computed(() &#x3D;&gt;\n  isExpand.value ? &quot;leaf-textarea-expand&quot; : &quot;leaf-textarea-collapse&quot;\n);\n\nconst collapseTextareaStyle &#x3D; computed(() &#x3D;&gt; &#123;\n  let textWidth &#x3D; null;\n  if (typeof width &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n    textWidth &#x3D; &#96;$&#123;width&#125;%&#96;;\n  &#125; else &#123;\n    textWidth &#x3D; width;\n  &#125;\n  return &#123;\n    &#x2F;&#x2F; 文本宽度\n    &quot;--leaf-text-width&quot;: textWidth,\n    &#x2F;&#x2F; 设置行高\n    &quot;--leaf-text-line-height&quot;: lineHeight + &quot;px&quot;,\n    &#x2F;&#x2F; 设置第n行开始省略\n    &quot;--leaf-text-hidden-line&quot;: defaultCollapseLine,\n  &#125;;\n&#125;);\n\nwatch(\n  () &#x3D;&gt; content,\n  () &#x3D;&gt; &#123;\n    nextTick(() &#x3D;&gt; &#123;\n      getTextHeight();\n    &#125;);\n  &#125;,\n  &#123;\n    deep: true,\n    immediate: true,\n  &#125;\n);\n\nfunction getTextHeight() &#123;\n  const rate &#x3D; window.innerWidth &#x2F; 375;\n  if (!contentRef.value) return;\n  const contentHeight &#x3D; contentRef.value?.offsetHeight;\n  isShowExpandBtn.value &#x3D;\n    contentHeight &gt; rate * defaultCollapseLine * lineHeight;\n  textHeight.value &#x3D; contentHeight;\n  if (isShowExpandBtn) isExpand.value &#x3D; false;\n&#125;\n\nfunction handleExpandText() &#123;\n  isExpand.value &#x3D; !isExpand.value;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.text-wrapper &#123;\n  width: var(--leaf-text-width);\n  line-height: var(--leaf-text-line-height);\n  overflow: hidden;\n  max-height: calc(var(--leaf-text-line-height) * var(--leaf-text-hidden-line));\n&#125;\n\n.text-button &#123;\n  margin-left: 5px;\n  margin-right: 10px;\n  height: var(--leaf-text-line-height);\n  float: right;\n  clear: both;\n  pointer-events: auto;\n\n  font-weight: 500;\n  font-size: 13px;\n  line-height: 18px;\n  text-align: right;\n  color: rgba(22, 24, 35, 0.75);\n  cursor: pointer;\n&#125;\n\n.leaf-textarea-collapse &#123;\n  pointer-events: none;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: var(--leaf-text-hidden-line);\n&#125;\n\n.leaf-textarea-collapse::before &#123;\n  content: &quot;&quot;;\n  float: right;\n  height: calc(\n    (var(--leaf-text-hidden-line) - 0.9) * var(--leaf-text-line-height)\n  );\n  width: 0;\n&#125;\n\n.leaf-textarea-expand &#123;\n  max-height: calc(\n    var(--leaf-text-hidden-line) * var(--leaf-text-line-height) * 1px\n  );\n  pointer-events: none;\n&#125;\n\n.down-arrow &#123;\n  margin-left: 5px;\n  margin-top: 6.5px;\n  float: right;\n  width: 0;\n  height: 0;\n  border-width: 5px;\n  border-style: solid;\n  border-color: rgba(22, 24, 35, 0.75) transparent transparent transparent;\n&#125;\n\n.up-arrow &#123;\n  margin-left: 5px;\n  float: right;\n  width: 0;\n  height: 0;\n  border-width: 5px;\n  border-style: solid;\n  border-color: transparent transparent rgba(22, 24, 35, 0.75) transparent;\n&#125;\n&lt;&#x2F;style&gt;","slug":"前端CSS-实现展开收起","date":"2023-02-18T04:19:20.000Z","categories_index":"前端","tags_index":"css","author_index":"YeZhou"},{"id":"2951c741688259208b1fb3af7c687644","title":"算法-回文数","content":"回文数\n\n\n\n\n\n\n\n\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n例如，121 是回文，而 123 不是。\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/palindrome-number\nversion 1/**\n * @param &#123;number&#125; x\n * @return &#123;boolean&#125;\n */\nvar isPalindrome = function(x) &#123;\n    let leftIndex = 0\n    let rightIndex = x.toString().length-1\n    while(leftIndex&lt;rightIndex)&#123;\n        if(x.toString()[leftIndex]===x.toString()[rightIndex])&#123;\n            leftIndex++\n            rightIndex--\n        &#125;else &#123;\n            return false\n        &#125;\n    &#125;\n    return true\n&#125;;\n\n\nversion 2/**\n * @param &#123;number&#125; x\n * @return &#123;boolean&#125;\n */\nvar isPalindrome = function(x) &#123;\n     if(x&lt;0)&#123;\n        return false\n    &#125;else&#123;\n        x = x.toString().split('')\n        if(x.toString() === x.reverse().toString())&#123;\n            return true\n        &#125;else&#123;\n            return false\n        &#125;\n    &#125;\n&#125;;\n\n\n","slug":"算法-回文数","date":"2023-02-09T14:55:14.000Z","categories_index":"算法","tags_index":"算法","author_index":"YeZhou"},{"id":"aa2fd1521ca7cb521e2b48d5d97b1661","title":"前端CSS-grid","content":"css之grid\n\n\n\n\n\n\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/grid\nhttps://article.itxueyuan.com/GjlqAZ\n浏览器兼容性\n\n\n\n\n\n\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/grid#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7\n\n使用display: grid | inline-grid \ngrid\n该元素的行为类似块级元素并且根据网格模型布局它的内容。\n\n\ninline-grid\n元素的行为类似于内联元素并且它的内容根据网格盒模型布局。\n它等同于 inline grid。\n\n\n\n相关属性grid\n\n\n\n\n\n\n\n\ngrid 是一个 CSS 简写属性，可以用来设置以下属性：\n显式网格属性： grid-template-rows、grid-template-columns 和 grid-template-areas。\n隐式网格属性： grid-auto-rows、grid-auto-columns 和 grid-auto-flow。\n间距属性： grid-column-gap 和 grid-row-gap。\ngrid-template-rows\n\n\n\n\n\n\n\n\ngrid-template-rows 该属性是基于 网格行 的维度，去定义网格线的名称和网格轨道的尺寸大小。\ngrid-template-columns\n\n\n\n\n\n\n\n\ngrid-template-columns 该属性是基于 网格列. 的维度，去定义网格线的名称和网格轨道的尺寸大小。\ngrid-template-areas\n\n\n\n\n\n\n\n\ngrid-template-areas CSS 属性是网格区域 grid areas 在 CSS 中的特定命名。\ngrid-auto-rows\n\n\n\n\n\n\n\n\nCSS 属性 grid-auto-rows 用于指定隐式创建的行轨道大小。\ngrid-auto-columns\n\n\n\n\n\n\n\n\nCSS 属性 grid-auto-columns 指定了隐式创建的网格纵向轨道（track）的宽度。\ngrid-auto-flow\n\n\n\n\n\n\n\n\ngrid-auto-flow 属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。\ncolumn-gap\n\n\n\n\n\n\n\n\nCSS column-gap 属性用来设置元素列之间的间隔（gutter）大小。\nrow-gap\n\n\n\n\n\n\n\n\nrow-gap 该 CSS 属性用来设置行元素之间的间隙（gutter）大小。\n","slug":"前端CSS-grid","date":"2023-02-08T14:29:01.000Z","categories_index":"前端","tags_index":"css","author_index":"YeZhou"},{"id":"8e8b26a29bbce2f2f0407f66f7aea70a","title":"部署-关于部署记录","content":"关于部署的那些事\n\n\n\n\n\n\n\n\n最近记性不太好，先记录留待之后慢慢补充吧~\n\n一、docker安装及相关操作\n安装docker\n\nyum install docker\n\n查看版本\n\ndocker version\n\n[root@VM_0_10_centos ~]# docker --version\nDocker version 1.13.1, build 07f3374/1.13.1\n[root@VM_0_10_centos ~]# docker version\nClient:\nVersion:         1.13.1\nAPI version:     1.26\nPackage version:\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n\n\n\n\n\n\n\n\n\n\n在运行docker的过程中可能会弹出这个报错~Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?可以通过这个指令解决service docker start\n\ndocker运行容器指令\n\ndocker run -it 镜像名 /bin/bash\n\n\ndocker退出容器\n\nexit\n\n\ndocker查看容器\n\ndocker ps -a\n\n\ndocker查看运行的容器\n\n\ndocker ps\n\n\ndocker重启容器\n\ndocker restart 容器ID\n\n\ndocker进入容器\n\ndocker exec -it 容器ID /bin/bash\n\n二、MongoDB安装及相关操作\n查找docker中的mongo\n\ndocker search mongo\n\n\n直接拉取最新版本\n\ndocker pull mongo:latest\n\n\n查看是否已经安装docker\n\ndocker images\n\n\n运行容器\n\ndocker run -itd --name mongo -p 27017:27017 mongo --auth\n\n\n\n\n\n\n\n\n\n\n-p 27017:27017 ：映射容器服务的 27017 端口到宿主机的 27017 端口–auth：需要密码才能访问容器服务\n\n到这里就安装成功啦~可以通过docker ps查看容器的运行信息\n\n添加用户名和密码，并连接\n\n\n$ docker exec -it mongo mongo admin\n# 创建一个名为 admin，密码为 123456 的用户。\n>  db.createUser(&#123; user:'admin',pwd:'123456',roles:[ &#123; role:'userAdminAnyDatabase', db: 'admin'&#125;,\"readWriteAnyDatabase\"]&#125;);\n# 尝试使用上面创建的用户信息进行连接。\n> db.auth('admin', '123456')\n\n三、node安装及相关操作\nnode查看版本\n\ndocker search node\n\n\n获取最新的node镜像版本\n\ndocker pull node:latest\n\n\n查看当前本地images镜像\n\ndocker images\n\n\n运行容器\n\ndocker run -itd --name node node\n\n\n进入容器查看node版本\n\ndocker exec -it node /bin/bash\n\n\n全局安装pm2\n\nnpm install -g pm2\n\n四、关于文件上传的那些事\n安装依赖\n\nyum -y install lrzsz \n\n\n上传文件\n\nrz\n\n\n下载文件\n\nsz\n\n\n由于rz只能上传文件不能上传文件夹，所以需要打包之后上传，上传之后需要解压操作\n\nunzip 压缩文件名 -d 压缩后的文件名\n// example\nunzip name-a.zip -d name-b\n\n五、Koa项目部署\n在项目根目录创建Dockerfile\n\nFROM node:alpine\nADD . /app/\nWORKDIR /app\nRUN yarn install\nEXPOSE 3000\nCMD [\"yarn\", \"start\"]\n\n\n将项目上传至服务器中\n\n构建镜像\n\n\ndocker build -t 镜像名 .\n\n\n\n\n\n\n\n\n\n\n千万不要忘记最后有个点 .\n\n运行镜像\n\n#启动镜像 -d表示后台执行，-p 9000:3000表示指定本地的9000端口隐射到容器内的3000端口，docker_demo为镜像名称\ndocker run -d -p 9000:3000 docker_demo\n\n六、部署前端项目\n安装nginx\n\ndocker pull nginx\n\n\n查看镜像\n\ndocker images\n\n\n在项目根目录中增加default.conf有关nginx配置\n\nserver &#123;\n    listen       80;\n    server_name  主机IP; # 修改为docker服务宿主机的ip\n\n    location / &#123;\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html =404;\n    &#125;\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html &#123;\n        root   html;\n    &#125;\n&#125;\n\n\n同上，在根目录创建Dockerfile文件\n\nFROM nginx\n\nRUN rm /etc/nginx/conf.d/default.conf\n\nADD default.conf /etc/nginx/conf.d/\n\nCOPY dist/ /usr/share/nginx/html/\n\n\n上传至服务器之后构建docker镜像\n\ndocker build -t blog-web .\n\n\n启动docker容器\n\ndocker run -d -p 80:80 --name blog-web blog-web\n\n\n那么，就可以愉快的玩耍了~\n\n","slug":"部署-关于部署记录","date":"2023-02-07T01:45:05.000Z","categories_index":"部署","tags_index":"docker,部署","author_index":"YeZhou"},{"id":"b83abc25e368a59d9f3334fe1d7a129e","title":"生活-毕业旅行那些事","content":"\n\n\n\n\n\n\n\n\n\n[20220422成都]总要有一场旅行，从成都走到西藏，趁着年轻，把最好的时光花在丈量距离\n\n\n\n\n\n\n\n\n\n\n[20220422磨西古镇]我还可以躺在山顶触摸星星，与月亮窃窃私语，像好久不见的老朋友一样\n\n\n\n\n\n\n\n\n\n\n[20220423海螺沟]保持热爱 奔赴山海 第一站从海螺沟开始\n未完待续…\n","slug":"生活-毕业旅行的那些事","date":"2022-09-17T17:36:02.000Z","categories_index":"生活","tags_index":"旅行","author_index":"YeZhou"},{"id":"635b0fbda2ef0819029f59569390b25d","title":"前端-关于webpack的一些优化","content":"关于webpack的优化\n\n\n\n\n\n\n\n\n在webpack打包的过程中，总是觉得等的时间好漫长，so，康康有没有啥方法可以提升一下打包的速度\nwebpack 5.68.0 compiled with 2 warnings in 29784 ms\nDone in 31.27s\n\nProgressPlugin\n\n\n\n\n\n\n\n\n咱想知道一下打包进度是啥，等着好无聊\nconst &#123; ProgressPlugin &#125; = require(\"webpack\");\n\n  plugins: [\n    ...\n    new ProgressPlugin(&#123;\n      activeModules: true,\n      entries: true,\n      modules: true,\n      modulesCount: 5000,\n      profile: false,\n      dependencies: false,\n      dependenciesCount: 10000,\n    &#125;),\n  ],\n\ncache-loader\n\n\n\n\n\n\n\n\n\n在一些性能开销较大的 loader 之前添加此 loader，以将结果缓存到磁盘里\n请注意，保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。\n\nyarn add cache-loader -D\n\n&#123;\n  test: /\\.(tsx|ts)$/,\n  use: [\n    \"cache-loader\",\n    &#123;\n      loader: \"babel-loader\",\n      options: &#123;\n        presets: [\"@babel/preset-react\"],\n        cacheDirectory: true,\n      &#125;,\n    &#125;,\n    \"ts-loader\",\n  ],\n  exclude: path.resolve(__dirname, \"node_modules\"),\n&#125;,\n\n重新yarn build一下，发现速度快了6s~\nwebpack 5.68.0 compiled with 2 warnings in 23323 ms\nDone in 25.20s\n\nwebpack-parallel-uglify-pluginyarn add webpack-parallel-uglify-plugin -D\n\n在webpack中增加以下配置\nconst ParallelUglifyPlugin = require(\"webpack-parallel-uglify-plugin\");\n\n  plugins: [\n    new ParallelUglifyPlugin(&#123;\n      cacheDir: \".cache/\",\n      uglifyJS: &#123;\n        output: &#123;\n          beautify: false,\n          comments: false,\n        &#125;,\n        warnings: false,\n      &#125;,\n      test: /.(js|ts|tsx)$/g,\n      sourceMap: false,\n    &#125;),\n  ],\n\n真好，又优化了2s左右的时间\nwebpack 5.68.0 compiled with 2 warnings in 21980 ms\nDone in 23.34s.\n\nsplitChunks\n\n\n\n\n\n\n\n\n我们可以使用 SplitChunks 的分块策略\noptimization: &#123;\n  //...\n  splitChunks: &#123;\n    // async异步导入\n    // initoal同步导入\n    // all 异步/同步\n    chunks: 'all',\n    minSize: 20000,  // 最小尺寸，拆分出来的一个包的大小最小为minSize 默认 20kb\n    maxSize: 20000,  // 将大于maxSize的包，拆成不小于minSize的包 默认 0， 一般会设置和minSize一样\n    minChunks: 2,    // 引入的包，至少被导入几次 默认 1次\n    cacheGroups: &#123;   // 缓存分组\n      vendor: &#123;  // 第三方打包到vendor\n        test: /[\\/]node_modules[\\/]/,  // 匹配node_modules\n        filename: 'js/[id]_vendors.js',  // 与name属性区别是 filename可用占位符, name固定名称\n        // name: 'js/check_vendors.js',  \n        priority: -10  // 当所有打包条件都满足时，按priority优先级来打包，大的先打包\n      &#125;,\n      default: &#123;  // 默认打包，当其他条件不满足\n        minChunks: 2,\n        filename: 'js/[id]_common.js',  // 一般是多入口会打包common.js\n        priority: -20\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n重新打包一次，哇哦，又快了~\nwebpack 5.68.0 compiled with 2 warnings in 19554 ms\nDone in 21.19s.\n\nterser-webpack-pluginconst TerserPlugin = require('terser-webpack-plugin')\n//...\noptimization: &#123;\n  minimize: true,  // minimizer配置开关\n  minimizer: [\n    new TerserPlugin(&#123;   // 默认不需要去配置, 压缩js\n      parallel: true,   // 使用cpu多核来构建\n      extractComments: false,  // 打包后的 LICENSE.txt 注释文件去吃\n      terserOptions: &#123;\n        compress: &#123;\n          arguments: true,\n          dead_code: true,\n        &#125;, // 设置压缩相关的选项；\n        mangle: true, // 设置丑化相关的选项，可以直接设置为true；\n        toplevel: true, // 底层变量是否进行转换；\n        keep_classnames: false, // 保留类的名称；\n        keep_fnames: false, // 保留函数的名称；\n      &#125;\n    &#125;),\n  ],\n&#125;\n\n18.69s，啊，真香\nwebpack 5.68.0 compiled with 2 warnings in 17272 ms\nDone in 18.69s.\n","slug":"前端-关于webpack的一些优化","date":"2022-09-17T07:31:38.000Z","categories_index":"前端","tags_index":"webpack,优化","author_index":"YeZhou"},{"id":"8af2236542193075f01a57f43d7db5c6","title":"前端-无头浏览器大佬借鉴指南","content":"无头浏览器\n\n\n\n\n\n\n\n\n参考链接\nhttps://www.zhihu.com/question/314668782/answer/615201155\nhttps://juejin.cn/post/6844903504276881422\nhttps://blog.51cto.com/u_15127557/3781423\nhttps://www.infoq.cn/article/ZZDG2iqhZ73elE8vIsye\nhttps://blog.csdn.net/weixin_45426836/article/details/111462607\nhttps://www.jianshu.com/p/92cfecd94ada\nhttps://www.jianshu.com/p/7f5a7bd79f59/\n是个啥“无头”这个词来源于最初的“无头计算机(Headless computer)”。维基百科关于的“无头计算机”词条：\n\n\n\n\n\n\n\n\n\n无头系统（headless system）是指已配置为无须显示器（即“头”）、键盘和鼠标操作的计算机系统或设备。无头系统通常通过网络连接控制，但也有部分无头系统的设备需要通过 RS-232 串行连接进行设备的管理。服务器通常采用无头模式以降低运作成本。\n\n简单来说就是通过编程来控制它自动执行测试、截屏等任务\n\n有啥好处\n软件生产中的自动化\n无头浏览器比真正的浏览器更快\n节省开发人员的时间\n使用无头浏览器脚本监视性能\n\n无头浏览器种类\nPhantomJS：Scriptable Headless WebKit 【Star - 25877】\nslimerjs：A scriptable browser like PhantomJS, based on Firefox 【Star - 2738】\nsplash：Lightweight, scriptable browser as a service with an HTTP API 【1974】\ntriflejs：Headless automation for Internet Explorer 【Star - 764】\n\n无头浏览器初探 puppeteer[demo1.js]\n关于 puppeteer\n\n\n\n\n\n\n\n\n\n\nhttps://www.youdao.com/result?word=puppeteer&amp;lang=en\n\n\n\n\n\n\n\n\n\nPuppeteer 的执行原理就是像操纵木偶的人一样，通过各种方式(接口)进行操纵浏览器帮你执行各种操作的工具\n\n\n\n\n\n\n\n\n\n\n\nPuppeteer 使用 DevTools 协议 与浏览器进行通信。\nBrowser 实例可以拥有浏览器上下文。\nBrowserContext 实例定义了一个浏览会话并可拥有多个页面。\nPage 至少有一个框架：主框架。 可能还有其他框架由 iframe 或 框架标签 创建。\nframe 至少有一个执行上下文 - 默认的执行上下文 - 框架的 JavaScript 被执行。 一个框架可能有额外的与 扩展 关联的执行上下文。\nWorker 具有单一执行上下文，并且便于与 WebWorkers 进行交互。\n\n\n安装无头浏览器\n\npnpm add puppeteer\n\n\n\n\n\n\n\n\n\n\n此处贴一下 puppeteer 的文档：http://www.puppeteerjs.com/\n\n实现简易 DEMO\n\nconst puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.baidu.com\");\n  leafConsole(INFO_SUCCESS, \"open http://www.baidu.com success\");\n  await page.close();\n  leafConsole(INFO_SUCCESS, \"close http://www.baidu.com success\");\n&#125;\n\nheadlessTest();\n\n通过以上代码，可以运行http://www.baidu.com，并在之后关闭浏览器。\n如何判断无头浏览器[demo2.js]\n通过 User Agent 判断\n\nif (/HeadlessChrome/.test(window.navigator.userAgent)) &#123;\n  console.log(\"Chrome headless detected\");\n&#125;\n\n\n通过 plugins 判断\n\nif (navigator.plugins.length == 0) &#123;\n  console.log(\"It may be Chrome headless\");\n&#125;\n\n\nnavigate.languages\n\n\n\n\n\n\n\n\n\n\nnavigator.language 和 navigator.languages。头一个是指浏览器界面的语言，后一个返回的是个数组，里面存储的是浏览器用户的所有次选语言。然而，在无头模式里，navigator.languages 返回的是个空字符串\nif (navigator.languages == \"\") &#123;\n  console.log(\"Chrome headless detected\");\n&#125;\n\n\n\n\n\n\n\n\n\n\n当然还有其它方法，就先列举了一些\n无头浏览器的能干啥\n生成网页的截图或者 PDF 文件\n模拟键盘的操作、对 UI 进行测试、对表单进行提交\n用浏览器自带的分析工具对页面进行分析\n等等\n\n无头浏览器的使用生成网页的截图或者 PDF 文件[demo2.js]const puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.baidu.com\", &#123;\n    waitUntil: \"load\",\n  &#125;);\n  try &#123;\n    await page.screenshot(&#123; path: `../assets/$&#123;new Date().getTime()&#125;.png` &#125;);\n    leafConsole(INFO_SUCCESS, \"screenshot png success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"screenshot png failure\");\n  &#125;\n  try &#123;\n    await page.pdf(&#123; path: `../assets/$&#123;new Date().getTime()&#125;.pdf` &#125;);\n    leafConsole(INFO_SUCCESS, \"screenshot pdf success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"screenshot pdf failure\");\n  &#125;\n  await page.close();\n&#125;\n\nheadlessTest();\n\n模拟操作[demo3.js]const puppeteer = require(\"puppeteer\");\nconst request = require(\"request\");\nconst &#123; createWriteStream &#125; = require(\"fs\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n  const page = await browser.newPage();\n\n  try &#123;\n    await page.goto(\"http://image.baidu.com\", &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await page.waitForSelector(\"html\");\n    leafConsole(INFO_SUCCESS, \"open image.baidu.com success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"open image.baidu.com failure\");\n    return;\n  &#125;\n\n  try &#123;\n    await page.type(\"#kw\", \"小姐姐\");\n    await page.click(\"#homeSearchForm > .s_btn_wr\");\n    await page.waitForSelector(\".imgitem > a\");\n    leafConsole(INFO_SUCCESS, \"search key success\");\n  &#125; catch (err) &#123;\n    leafConsole(INFO_FAILURE, \"search key failure\");\n    return;\n  &#125;\n\n  const urls = await page.$$eval(\".imgitem > a\", (img) =>\n    img.map((imgItem) => imgItem.href)\n  );\n  for (let i = 0; i &lt; urls.length; i++) &#123;\n    await page.goto(urls[i], &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await downLoadImg(page, i);\n  &#125;\n&#125;\n\nasync function downLoadImg(page, index) &#123;\n  await page.waitForSelector(\".currentImg\");\n  const imgSrc = await page.evaluate(() => &#123;\n    let img = document.querySelector(\".currentImg\");\n    return img.src;\n  &#125;);\n  try &#123;\n    const fileName = `$&#123;new Date().getTime()&#125;-$&#123;index&#125;-小姐姐.png`;\n    await download(imgSrc, `../assets/$&#123;fileName&#125;`);\n    leafConsole(INFO_SUCCESS, `download success filename:$&#123;fileName&#125;`);\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"download failure\");\n  &#125;\n&#125;\n\nfunction download(path, name) &#123;\n  return new Promise((resolve, reject) => &#123;\n    let ws = new createWriteStream(name);\n    ws.on(\"finish\", function () &#123;\n      ws.end();\n      resolve();\n    &#125;);\n    ws.on(\"error\", reject);\n    request(&#123;\n      url: path,\n      headers: &#123;\n        Referer: \"no-referrer-when-downgrade\",\n        \"User-Agent\":\n          \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\",\n      &#125;,\n    &#125;).pipe(ws);\n  &#125;);\n&#125;\n\nheadlessTest();\n\n测试页面性能[demo4.js]const puppeteer = require(\"puppeteer\");\nconst &#123; INFO_SUCCESS, leafConsole &#125; = require(\"./constants\");\n\nconst targetUrl = \"http://image.baidu.com\";\nconst times = 5;\nconst record = [];\n\nasync function headlessTest() &#123;\n  for (let i = 0; i &lt; times; i++) &#123;\n    const browser = await puppeteer.launch(&#123; headless: true &#125;);\n    const page = await browser.newPage();\n    await page.goto(targetUrl, &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n\n    const timing = JSON.parse(\n      await page.evaluate(() => JSON.stringify(window.performance.timing))\n    );\n    const res = calculate(timing);\n    record.push(res);\n    await browser.close();\n    leafConsole(INFO_SUCCESS, `End of the test[$&#123;i + 1&#125;/$&#123;times&#125;]`);\n    leafConsole(INFO_SUCCESS, `whiteScreenTime:$&#123;res.whiteScreenTime&#125;ms`);\n    leafConsole(INFO_SUCCESS, `requestTime:$&#123;res.requestTime&#125;ms`);\n  &#125;\n\n  let whiteScreenTime = 0;\n  let requestTime = 0;\n\n  for (let item of record) &#123;\n    whiteScreenTime += item.whiteScreenTime;\n    requestTime += item.requestTime;\n  &#125;\n\n  leafConsole(INFO_SUCCESS, `---------result---------`);\n  leafConsole(INFO_SUCCESS, `targetUrl:$&#123;targetUrl&#125;`);\n  leafConsole(\n    INFO_SUCCESS,\n    `The average blank screen time is:$&#123;whiteScreenTime / times&#125; ms`\n  );\n  leafConsole(\n    INFO_SUCCESS,\n    `The average page request time is:$&#123;requestTime / times&#125; ms`\n  );\n&#125;\n\nfunction calculate(timing) &#123;\n  const result = &#123;&#125;;\n  // 白屏时间\n  result.whiteScreenTime = timing.responseStart - timing.navigationStart;\n  // 请求时间\n  result.requestTime = timing.responseEnd - timing.responseStart;\n  return result;\n&#125;\n\nheadlessTest();\n\n爬虫[demo5.js]const puppeteer = require(\"puppeteer\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst &#123; INFO_SUCCESS, leafConsole, INFO_FAILURE &#125; = require(\"./constants\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n  const page = await browser.newPage();\n\n  try &#123;\n    await page.goto(\"http://image.baidu.com\", &#123;\n      waitUntil: \"domcontentloaded\",\n    &#125;);\n    await page.waitForSelector(\"html\");\n    leafConsole(INFO_SUCCESS, \"open image.baidu.com success\");\n  &#125; catch &#123;\n    leafConsole(INFO_FAILURE, \"open image.baidu.com failure\");\n    return;\n  &#125;\n\n  try &#123;\n    await page.type(\"#kw\", \"小姐姐\");\n    await page.click(\"#homeSearchForm > .s_btn_wr\");\n    await page.waitForSelector(\".imgitem > a\");\n    leafConsole(INFO_SUCCESS, \"search key success\");\n  &#125; catch (err) &#123;\n    leafConsole(INFO_FAILURE, \"search key failure\");\n    return;\n  &#125;\n\n  const urls = await page.$$eval(\".imgitem > a\", (img) =>\n    img.map((imgItem) => (&#123;\n      src: imgItem.href,\n      title: imgItem.title,\n      name: imgItem.name,\n    &#125;))\n  );\n\n  let list = JSON.stringify(urls);\n  let file = path.join(\"../assets/\", `test-$&#123;new Date().getTime()&#125;.json`);\n  fs.writeFile(file, list, (err) => &#123;\n    if (err) &#123;\n      leafConsole(INFO_FAILURE, \"export json error\");\n      return;\n    &#125;\n    leafConsole(INFO_SUCCESS, \"export json success\");\n  &#125;);\n&#125;\n\nheadlessTest();\n\n监听请求和响应[demo6.js]const puppeteer = require(\"puppeteer\");\n\nasync function headlessTest() &#123;\n  const browser = await puppeteer.launch(&#123;\n    headless: true,\n  &#125;);\n\n  const page = await browser.newPage();\n  await page.goto(\"http://www.yeyezhou.com\");\n\n  page.on(\"request\", (request) => &#123;\n    if (request.url() === \"http://www.yeyezhou.com/api/a/article/list\") &#123;\n      console.log(request.resourceType());\n      console.log(request.method());\n      console.log(request.headers());\n    &#125;\n  &#125;);\n\n  page.on(\"response\", (response) => &#123;\n    if (response.url() === \"http://www.yeyezhou.com/api/a/article/list\") &#123;\n      console.log(response.status());\n      console.log(response.headers());\n    &#125;\n  &#125;);\n&#125;\n\nheadlessTest();\n\n无头浏览器优化\n\n\n\n\n\n\n\n\nhttps://www.jianshu.com/p/7f5a7bd79f59/\nhttps://juejin.cn/post/6844903984101064717\n优化 Chromium 启动项\n\n\n\n\n\n\n\n\nChromium 启动参数表：https://peter.sh/experiments/chromium-command-line-switches/\n网上大佬的优化配置参数\nconst browser = await puppeteer.launch(&#123;\n  headless: true,\n  args: [\n    \"–disable-gpu\",\n    \"–disable-dev-shm-usage\",\n    \"–disable-setuid-sandbox\",\n    \"–no-first-run\",\n    \"–no-sandbox\",\n    \"–no-zygote\",\n    \"–single-process\",\n  ],\n&#125;);\n\n优化 Chromium 执行流程\n\n\n\n\n\n\n\n\n优化的其中一种手段就是减少 Chromium 启动的次数，做到复用 Chromium 每次只打开一个 tab 页然后关闭。可以使用 puppeteer 提供的 puppeteer.connect()方法连接到当前打开的浏览器\n通过这种方法，可以把流程 A 成功优化成流程 B\nA\n请求到达-&gt;启动 Chromium-&gt;打开 tab 页-&gt;运行代码-&gt;关闭 tab 页-&gt;关闭 Chromium-&gt;返回数据\nB\n请求到达-&gt;连接 Chromium-&gt;打开 tab 页-&gt;运行代码-&gt;关闭 tab 页-&gt;返回数据\n\n\n\n\n\n\n\n\n\n使用puppeteer.connect比puppeteer.launch启动一个浏览器实例要快很多,所以当我们需要开启多个broswer实例时，可以通过缓存wsEndpoint来达到复用的目的\nlet wsEndpoint = await cache.get(Parser.WS_KEY);\nlet broswer;\ntry &#123;\n    browser = !wsEndpoint\n        ? await puppeteer.launch(config)\n        : await puppeteer.connect(&#123;\n              browserWSEndpoint: this.wsEndpoint,\n          &#125;);\n&#125; catch (err) &#123;\n    browser = await puppeteer.launch(config);\n&#125; finally &#123;\n    wsEndpoint = this.browser.wsEndpoint();\n    await cache.set(Parser.WS_KEY, 60 * 60 * 1000, this.wsEndpoint);\n&#125;\n\n利用 cluster 优化 Puppeteer\n\n\n\n\n\n\n\n\n通常情况下我们会使用 ​.map()​ 搭配 ​Promise.all()​ 的方式并行处理异步，但是在使用 ​Puppeteer​ 批量截图时发现 ​Promise.all​ 会打开多个浏览器，导致机器性能急剧下降。\n\n\n\n\n\n\n\n\n\nCluster 原理解析：https://zhuanlan.zhihu.com/p/157987519\n避免使用 page.waitFor 让程序自己决定啥时候继续会更好拦截一些没有必要加载的资源\n\n\n\n\n\n\n\n\n当我们使用 puppeteer 对页面异步渲染的 dom 结构进行解析时，往往需要等待页面完成渲染完成之后，才能使用脚本进行操作。但页面渲染过程中也包含了许多静态资源如：图片&#x2F;音频&#x2F;视频&#x2F;样式文件等。此时我们可以通过 page.setRequestInterception 方法，对网页请求进行过滤，拦截静态资源的请求，加快页面渲染速度。代码示例如下：\n// 开启请求拦截功能\npage.setRequestInterception(true);\n\npage.on('request', async req => &#123;\n    // 根据请求类型过滤\n    const resourceType = req.resourceType();\n    if (resourceType === 'image') &#123;\n        req.abort();\n    else &#123;\n        req.continue();\n    &#125;\n&#125;);\n\nconst blockedResourceTypes &#x3D; [\n    &#39;image&#39;,\n    &#39;media&#39;,\n    &#39;font&#39;,\n    &#39;texttrack&#39;,\n    &#39;object&#39;,\n    &#39;beacon&#39;,\n    &#39;csp_report&#39;,\n    &#39;imageset&#39;,\n];\n\nconst skippedResources &#x3D; [\n    &#39;quantserve&#39;,\n    &#39;adzerk&#39;,\n    &#39;doubleclick&#39;,\n    &#39;adition&#39;,\n    &#39;exelator&#39;,\n    &#39;sharethrough&#39;,\n    &#39;cdn.api.twitter&#39;,\n    &#39;google-analytics&#39;,\n    &#39;googletagmanager&#39;,\n    &#39;google&#39;,\n    &#39;fontawesome&#39;,\n    &#39;facebook&#39;,\n    &#39;analytics&#39;,\n    &#39;optimizely&#39;,\n    &#39;clicktale&#39;,\n    &#39;mixpanel&#39;,\n    &#39;zedo&#39;,\n    &#39;clicksor&#39;,\n    &#39;tiqcdn&#39;,\n];","slug":"前端-无头浏览器初探","date":"2022-09-17T07:31:38.000Z","categories_index":"前端","tags_index":"无头浏览器,puppeteer","author_index":"YeZhou"}]